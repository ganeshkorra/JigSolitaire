<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>JigSolitaire - Zero Artifact Pro</title>
    <script src="https://cdn.jsdelivr.net/npm/canvas-confetti@1.6.0/dist/confetti.browser.min.js"></script>
    <style>
        :root { 
            --accent: #38bdf8; --correct: #4ade80; --bg: #0f172a; 
            --grid-size: 3;
            --slide-speed: 0.65s;
            --natural-ease: cubic-bezier(0.25, 1, 0.5, 1);
        }

        body {
            font-family: 'Segoe UI', sans-serif;
            background-color: var(--bg); margin: 0; padding: 0;
            display: flex; flex-direction: column;
            align-items: center; justify-content: center;
            height: 100vh; width: 100vw; color: white; overflow: hidden;
            touch-action: none; user-select: none;
        }

        #game-container { position: relative; width: 94vw; max-width: 380px; }
        
        #game-board {
            display: grid;
            grid-template-columns: repeat(var(--grid-size), 1fr);
            grid-gap: 1.5px;
            background: #0f172a; padding: 4px; border-radius: 12px;
            width: 100%; box-sizing: border-box;
            border: 2.5px solid #334155; position: relative;
        }

        .tile {
            width: 100%; aspect-ratio: 1/1; background-repeat: no-repeat;
            border-radius: 4px; box-sizing: border-box;
            cursor: grab; opacity: 1;
            transition: opacity 0.2s ease;
        }

        /* ðŸ§© The Cluster logic: closes gaps when matched */
        .tile.merged-left { border-left: none; margin-left: -2px; width: calc(100% + 2px); }
        .tile.merged-top { border-top: none; margin-top: -2px; height: calc(100% + 2px); }

        /* ðŸ‘» THE GHOST LAYER (Improved CSS) */
        #drag-ghost {
            position: fixed; top: 0; left: 0;
            pointer-events: none; /* User can't click the ghost, only through it */
            z-index: 9999; 
            visibility: hidden; /* HIDDEN UNTIL MAPPED */
            will-change: transform;
        }

        .ghost-tile {
            position: absolute; background-repeat: no-repeat;
            box-shadow: 0 10px 40px rgba(0,0,0,0.8); 
            border-radius: 6px; border: 1.5px solid white;
        }

        #final-image {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            border-radius: 12px; opacity: 0; pointer-events: none;
            transition: opacity 1.5s ease; z-index: 8000; object-fit: cover;
        }
        .reveal-state #final-image { opacity: 1; }
    </style>
</head>
<body>

    <div id="game-container">
        <img id="final-image" src="girl/Girl.png">
        <div id="game-board"></div>
    </div>

    <!-- The Single-Layer Drag Plane -->
    <div id="drag-ghost"></div>

    <script>
        const puzzleImg = 'girl/Girl.png';
        const grid = 3; 
        let order = Array.from(Array(grid * grid).keys());
        let done = false;
        
        const board = document.getElementById('game-board');
        const ghost = document.getElementById('drag-ghost');

        function start() {
            order = order.sort(() => Math.random() - 0.5);
            draw(false);
        }

        function draw(anim = true) {
            board.innerHTML = '';
            order.forEach((pid, idx) => {
                const t = document.createElement('div');
                t.className = 'tile';
                t.style.backgroundImage = `url("${puzzleImg}")`;
                t.style.backgroundSize = `${grid * 100}% ${grid * 100}%`;
                const c = pid % grid, r = Math.floor(pid / grid);
                t.style.backgroundPosition = `${(c * (100/(grid-1)))}% ${(r * (100/(grid-1)))}%`;
                t.dataset.index = idx;
                
                if (pid === idx) {
                    if (idx % grid !== 0 && order[idx-1] === idx-1) t.classList.add('merged-left');
                    if (idx >= grid && order[idx-grid] === idx-grid) t.classList.add('merged-top');
                }

                t.onpointerdown = (e) => beginDrag(e, idx);
                board.appendChild(t);
            });
        }

        // Logic for group moving
        function getGroup(i) {
            if (order[i] !== i) return [i];
            const g = [], q = [i], vis = new Set();
            while(q.length > 0) {
                const n = q.shift();
                if (vis.has(n)) continue; vis.add(n); g.push(n);
                [n-1, n+1, n-grid, n+grid].forEach(nb => {
                    if (nb >= 0 && nb < grid*grid && order[nb] === nb) {
                        const sR = Math.floor(n/grid) === Math.floor(nb/grid);
                        if ((nb === n-1 || nb === n+1) && !sR) return;
                        q.push(nb);
                    }
                });
            }
            return g;
        }

        function beginDrag(e, startIdx) {
            if(done) return;
            
            const group = getGroup(startIdx);
            const tiles = document.querySelectorAll('.tile');
            const pSize = tiles[0].offsetWidth;
            const rS = tiles[startIdx].getBoundingClientRect();

            // 1. GATHER OFFSET (Relative thumb position)
            const offX = e.clientX - rS.left;
            const offY = e.clientY - rS.top;

            // 2. CLEAR & RE-FILL THE GHOST CONTAINER (While invisible)
            ghost.innerHTML = '';
            group.forEach(idx => {
                const pid = order[idx];
                const gT = document.createElement('div');
                gT.className = 'ghost-tile';
                gT.style.width = pSize + 'px'; gT.style.height = pSize + 'px';
                gT.style.backgroundImage = `url("${puzzleImg}")`;
                gT.style.backgroundSize = `${grid * 100}% ${grid * 100}%`;
                const c = pid % grid, r = Math.floor(pid / grid);
                gT.style.backgroundPosition = `${(c * (100/(grid-1)))}% ${(r * (100/(grid-1)))}%`;
                
                const cD = (idx % grid) - (startIdx % grid);
                const rD = Math.floor(idx / grid) - Math.floor(startIdx / grid);
                gT.style.transform = `translate3d(${cD * pSize}px, ${rD * pSize}px, 0)`;
                ghost.appendChild(gT);
                
                // Hide real tile AFTER gathering
                tiles[idx].style.opacity = '0';
            });

            // 3. MAP POSITION FIRST, THEN SHOW (Kills the (0,0) Artifact)
            ghost.style.transform = `translate3d(${e.clientX - offX}px, ${e.clientY - offY}px, 0)`;
            ghost.style.visibility = 'visible';
            ghost.style.display = 'block';

            const move = (m) => {
                ghost.style.transform = `translate3d(${m.clientX - offX}px, ${m.clientY - offY}px, 0)`;
            };

            const up = (u) => {
                window.removeEventListener('pointermove', move);
                window.removeEventListener('pointerup', up);
                
                const hit = document.elementFromPoint(u.clientX, u.clientY);
                if (hit && hit.classList.contains('tile')) {
                    const dropIdx = parseInt(hit.dataset.index);
                    if (dropIdx !== startIdx) {
                        const newO = [...order];
                        let valid = true; const maps = [];
                        group.forEach(si => {
                            const cd = (si%grid)-(startIdx%grid), rd = Math.floor(si/grid)-Math.floor(startIdx/grid);
                            const ti = dropIdx + cd + (rd * grid);
                            if (ti < 0 || ti >= grid*grid || (Math.abs((ti % grid) - ((dropIdx + cd) % grid)) > 0)) valid = false;
                            maps.push({s:si, t:ti});
                        });

                        if (valid) {
                            const trB = hit.getBoundingClientRect();
                            ghost.style.transition = `transform var(--slide-speed) var(--natural-ease)`;
                            ghost.style.transform = `translate3d(${trB.left}px, ${trB.top}px, 0)`;

                            maps.forEach(m => {
                                if (!group.includes(m.t)) {
                                    const rectA = tiles[m.s].getBoundingClientRect(), rectB = tiles[m.t].getBoundingClientRect();
                                    tiles[m.t].style.transition = `transform var(--slide-speed) var(--natural-ease)`;
                                    tiles[m.t].style.transform = `translate3d(${rectA.left-rectB.left}px, ${rectA.top-rectB.top}px, 0)`;
                                }
                            });

                            setTimeout(() => {
                                maps.forEach(m => [newO[m.s], newO[m.t]] = [newO[m.t], newO[m.s]]);
                                order = newO; cleanup();
                            }, 660);
                            return;
                        }
                    }
                }
                cleanup();
            };
            
            window.addEventListener('pointermove', move);
            window.addEventListener('pointerup', up);
        }

        function cleanup() {
            ghost.style.display = 'none';
            ghost.style.visibility = 'hidden';
            ghost.style.transition = 'none';
            draw(false);
            if (order.every((v,i) => v===i)) {
                done = true; confetti();
                document.getElementById('game-container').classList.add('reveal-state');
            }
        }
        window.onload = start;
    </script>
</body>
</html>