<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>JigSolitaire Master - Pro</title>
    <script src="https://cdn.jsdelivr.net/npm/canvas-confetti@1.6.0/dist/confetti.browser.min.js"></script>
    <style>
        :root { 
            --accent: #38bdf8; 
            --correct: #4ade80; 
            --bg: #0f172a; 
            --grid-size: 3; 
            /* THE SMOOTHNESS SECRETS */
            --snap-speed: 0.5s;
            --ease: cubic-bezier(0.2, 1, 0.3, 1);
        }

        body {
            font-family: 'Segoe UI', sans-serif;
            background-color: var(--bg);
            margin: 0; padding: 0;
            display: flex; flex-direction: column;
            align-items: center; justify-content: center;
            height: 100vh; width: 100vw;
            color: white; overflow: hidden;
            touch-action: none; user-select: none;
        }

        #status { font-size: 1.2rem; margin-bottom: 25px; font-weight: 800; height: 30px; transition: all 0.3s; }

        #game-container { position: relative; width: 92vw; max-width: 380px; }
        
        #game-board {
            display: grid;
            grid-template-columns: repeat(var(--grid-size), 1fr);
            grid-gap: 4px;
            background: rgba(255,255,255,0.03);
            padding: 8px; border-radius: 16px;
            width: 100%; box-sizing: border-box;
            border: 2px solid #1e293b;
            position: relative;
        }

        .tile {
            width: 100%; aspect-ratio: 1/1;
            background-repeat: no-repeat;
            border-radius: 8px;
            box-sizing: border-box; position: relative;
            cursor: grab; opacity: 0;
            animation: flyIn 0.8s var(--ease) forwards;
            /* smooth border/transform updates */
            transition: border 0.4s, transform 0.4s var(--ease), opacity 0.3s;
            border: 1px solid rgba(255,255,255,0.05);
            will-change: transform, opacity;
        }

        .tile.correct-place { border: 2.5px solid var(--correct); z-index: 1; box-shadow: 0 0 15px rgba(74, 222, 128, 0.2); }

        @keyframes flyIn {
            from { transform: scale(0.5) rotate(-10deg); opacity: 0; }
            to { transform: scale(1) rotate(0); opacity: 1; }
        }

        /* Hover target feedback (While Dragging) */
        .tile.hovered { 
            transform: scale(0.92); 
            border: 3px solid var(--accent); 
            filter: brightness(1.2);
            z-index: 5;
        }

        /* Snap Pulse (Success) */
        .snap-anim { animation: snapPulse 0.4s var(--ease); }
        @keyframes snapPulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.1); filter: brightness(1.4); }
            100% { transform: scale(1); }
        }

        /* THE GHOST - Smooth Follower */
        #drag-ghost {
            position: fixed; background-repeat: no-repeat; opacity: 0;
            pointer-events: none; z-index: 3000; display: none;
            border-radius: 10px; box-shadow: 0 20px 50px rgba(0,0,0,0.8);
            transform: scale(1.08); border: 2px solid white;
            will-change: left, top, transform;
        }

        #tutorial-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            z-index: 2000; pointer-events: none; display: none;
        }

        #tutorial-hand {
            position: absolute; width: 60px; height: 60px;
            background: url('BubbleIdle.png') no-repeat center;
            background-size: contain;
            animation: smartHandMove 3.5s ease-in-out infinite;
        }

        @keyframes smartHandMove {
            0%, 100% { transform: translate(var(--fromX), var(--fromY)) scale(1.1); opacity: 0; }
            10% { opacity: 1; }
            25% { transform: translate(var(--fromX), var(--fromY)) scale(0.8); }
            65% { transform: translate(var(--toX), var(--toY)) scale(0.8); }
            85% { opacity: 1; transform: translate(var(--toX), var(--toY)) scale(1.1); }
            95% { opacity: 0; }
        }

        #final-image {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            border-radius: 16px; opacity: 0; pointer-events: none;
            transition: opacity 2s var(--ease); z-index: 100; object-fit: cover;
        }
        .reveal-state #game-board { opacity: 0.1; filter: blur(5px); }
        .reveal-state #final-image { opacity: 1; transform: scale(1.05); }
    </style>
</head>
<body>

    <div id="status">Assemble the Gallery</div>

    <div id="game-container">
        <div id="tutorial-overlay"><div id="tutorial-hand"></div></div>
        <img id="final-image" src="girl\Girl.png">
        <div id="game-board"></div>
    </div>

    <div id="drag-ghost"></div>

    <script>
        const puzzleImage = 'girl\Girl.png'; 
        const gridSize = 3; 
        const totalPieces = gridSize * gridSize;
        const originalOrder = Array.from(Array(totalPieces).keys());

        let currentOrder = [];
        let draggingIndex = null;
        let hintTimer = null;
        let isDone = false;
        
        const board = document.getElementById('game-board');
        const ghost = document.getElementById('drag-ghost');
        const overlay = document.getElementById('tutorial-overlay');

        function startGame() {
            // Keep top 3 correct, shuffle bottom 6
            const top = originalOrder.slice(0, 3);
            const shuf = originalOrder.slice(3).sort(() => Math.random() - 0.5);
            currentOrder = [...top, ...shuf];
            createBoard(true);
            setTimeout(setSmartHint, 2000);
        }

        function createBoard(animated = true, dropPulseIdx = null) {
            board.innerHTML = '';
            currentOrder.forEach((pieceId, index) => {
                const tile = document.createElement('div');
                tile.className = 'tile';
                tile.style.backgroundImage = `url("${puzzleImage}")`;
                tile.style.backgroundSize = `${gridSize * 100}% ${gridSize * 100}%`;
                
                const col = pieceId % gridSize;
                const row = Math.floor(pieceId / gridSize);
                tile.style.backgroundPosition = `${(col * (100 / (gridSize - 1)))}% ${(row * (100 / (gridSize - 1)))}%`;
                
                tile.dataset.index = index;
                if (pieceId === index) tile.classList.add('correct-place');
                if (index === dropPulseIdx) tile.classList.add('snap-anim');

                if (animated) {
                    tile.style.animationDelay = `${index * 0.04}s`;
                } else {
                    tile.style.animation = 'none'; tile.style.opacity = '1';
                }

                tile.onpointerdown = (e) => {
                    if(isDone) return;
                    hideHint();
                    startDrag(e, index, pieceId);
                };
                board.appendChild(tile);
            });
            resetHintTimer();
        }

        function startDrag(e, index, pieceId) {
            draggingIndex = index;
            const targetTile = e.currentTarget;
            const rect = targetTile.getBoundingClientRect();
            
            // Setup Ghost (The smooth mover)
            ghost.style.display = 'block';
            ghost.style.backgroundImage = `url("${puzzleImage}")`;
            ghost.style.backgroundSize = `${gridSize * 100}% ${gridSize * 100}%`;
            
            const col = pieceId % gridSize;
            const row = Math.floor(pieceId / gridSize);
            ghost.style.backgroundPosition = `${(col * (100 / (gridSize - 1)))}% ${(row * (100 / (gridSize - 1)))}%`;
            
            ghost.style.width = rect.width + 'px';
            ghost.style.height = rect.height + 'px';
            ghost.style.left = rect.left + 'px';
            ghost.style.top = rect.top + 'px';
            ghost.style.transition = "none";
            ghost.style.opacity = "1";

            targetTile.style.opacity = '0.05';

            const updatePos = (moveEvent) => {
                const x = moveEvent.clientX - rect.width / 2;
                const y = moveEvent.clientY - rect.height / 2;
                ghost.style.left = x + 'px';
                ghost.style.top = y + 'px';

                // Hit detection for Magnetic Hover effect
                document.querySelectorAll('.tile').forEach(t => t.classList.remove('hovered'));
                const hit = document.elementFromPoint(moveEvent.clientX, moveEvent.clientY);
                if (hit && hit.classList.contains('tile') && hit !== targetTile) {
                    hit.classList.add('hovered');
                }
            };

            window.addEventListener('pointermove', updatePos);

            window.addEventListener('pointerup', (upE) => {
                window.removeEventListener('pointermove', updatePos);
                const hit = document.elementFromPoint(upE.clientX, upE.clientY);
                const tiles = document.querySelectorAll('.tile');

                if (hit && hit.classList.contains('tile') && hit !== targetTile) {
                    const finalDropIdx = parseInt(hit.dataset.index);
                    const rectB = hit.getBoundingClientRect();

                    // 1. SLIDE GHOST TO TARGET SLOT
                    ghost.style.transition = `all var(--snap-speed) var(--ease)`;
                    ghost.style.left = rectB.left + 'px';
                    ghost.style.top = rectB.top + 'px';
                    ghost.style.transform = "scale(1)";

                    // 2. SLIDE TARGET PIECE TO STARTING SLOT
                    hit.style.zIndex = "100";
                    hit.style.transition = `transform var(--snap-speed) var(--ease)`;
                    hit.style.transform = `translate(${rect.left - rectB.left}px, ${rect.top - rectB.top}px)`;

                    // Wait for the "Physical glide" to finish
                    setTimeout(() => {
                        const tmp = currentOrder[draggingIndex];
                        currentOrder[draggingIndex] = currentOrder[finalDropIdx];
                        currentOrder[finalDropIdx] = tmp;
                        completeSwap(finalDropIdx);
                    }, 450);
                } else {
                    // Fail snap back
                    ghost.style.transition = `all 0.3s var(--ease)`;
                    ghost.style.left = rect.left + 'px';
                    ghost.style.top = rect.top + 'px';
                    ghost.style.transform = "scale(1)";
                    setTimeout(() => completeSwap(null), 300);
                }
            }, { once: true });
        }

        function completeSwap(pulseIdx) {
            draggingIndex = null;
            ghost.style.display = 'none';
            createBoard(false, pulseIdx);
            checkWin();
        }

        function setSmartHint() {
            if(isDone) return;
            let err = currentOrder.findIndex((val, i) => val !== originalOrder[i]);
            if (err === -1) return;

            const neededPiece = originalOrder[err];
            const foundAt = currentOrder.indexOf(neededPiece);
            const tiles = document.querySelectorAll('.tile');
            const boardRect = board.getBoundingClientRect();
            
            const A = tiles[foundAt].getBoundingClientRect();
            const B = tiles[err].getBoundingClientRect();

            overlay.style.setProperty('--fromX', `${A.left - boardRect.left + 25}px`);
            overlay.style.setProperty('--fromY', `${A.top - boardRect.top + 25}px`);
            overlay.style.setProperty('--toX', `${B.left - boardRect.left + 25}px`);
            overlay.style.setProperty('--toY', `${B.top - boardRect.top + 25}px`);
            overlay.style.display = 'block';
        }

        function resetHintTimer() {
            clearTimeout(hintTimer);
            if (!isDone) hintTimer = setTimeout(setSmartHint, 6000);
        }

        function hideHint() { overlay.style.display = 'none'; resetHintTimer(); }

        function checkWin() {
            if (currentOrder.every((v, i) => v === originalOrder[i])) {
                isDone = true;
                confetti({ particleCount: 200, spread: 80, origin: { y: 0.7 } });
                document.getElementById('status').innerText = "GALLERY RESTORED âœ¨";
                document.getElementById('status').style.color = "#4ade80";
                setTimeout(() => document.getElementById('game-container').classList.add('reveal-state'), 1000);
            }
        }

        window.onload = startGame;
    </script>
</body>
</html>