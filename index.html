<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>JigSolitaire - Pro Polish</title>
    <script src="https://cdn.jsdelivr.net/npm/canvas-confetti@1.6.0/dist/confetti.browser.min.js"></script>
    <style>
        :root { 
            --accent: #38bdf8; --bg: #0f172a; 
            --tileColor: #1e293b; --labelColor: #ffffff;
            --grid-cols: 3; --grid-rows: 3;
            --slide-speed: 0.5s;
            --natural-ease: cubic-bezier(0.2, 1, 0.3, 1);
        }

        body {
            font-family: 'Segoe UI', system-ui, sans-serif;
            background-color: var(--bg); margin: 0; padding: 0;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            height: 100vh; width: 100vw; color: white; overflow: hidden;
            touch-action: none; user-select: none;
        }

        #status-container { text-align: center; margin-bottom: 20px; z-index: 10; }
        #status { font-size: 1.2rem; font-weight: 900; letter-spacing: 2px; text-transform: uppercase; color: var(--labelColor); }

        #game-container { position: relative; width: 92vw; max-width: 400px; }
        
        #game-board {
            display: grid;
            grid-template-columns: repeat(var(--grid-cols), 1fr);
            grid-template-rows: repeat(var(--grid-rows), 1fr);
            grid-gap: 2px; background: rgba(0,0,0,0.4); 
            padding: 5px; border-radius: 12px;
            width: 100%; box-sizing: border-box; border: 2px solid rgba(255,255,255,0.1);
        }

        .tile {
            width: 100%; aspect-ratio: 1/1; background-repeat: no-repeat;
            border-radius: 4px; cursor: grab;
            background-color: var(--tileColor);
            will-change: transform, opacity;
            position: relative;
        }
        
        .tile.game-tile {
            opacity: 0;
            animation: boardEntrance 0.8s var(--natural-ease) both;
        }

        /* Back tile animation */
        .back-tile {
            position: absolute;
            width: 100%; height: 100%;
            background-repeat: no-repeat;
            background-size: cover;
            background-position: center;
            border-radius: 4px;
            transform-style: preserve-3d;
            backface-visibility: hidden;
            background-color: #1e90ff;
            background-image: 
                repeating-linear-gradient(45deg, transparent, transparent 10px, rgba(255,255,255,0.1) 10px, rgba(255,255,255,0.1) 20px),
                repeating-linear-gradient(-45deg, transparent, transparent 10px, rgba(255,255,255,0.1) 10px, rgba(255,255,255,0.1) 20px);
            border: 2px solid rgba(255,255,255,0.3);
        }

        @keyframes flyInFromBottomRight {
            0% { 
                transform: translate3d(400px, 400px, 0) scale(0.5); 
                opacity: 0; 
            }
            100% { 
                transform: translate3d(0, 0, 0) scale(1); 
                opacity: 1; 
            }
        }

        @keyframes flipAndHide {
            0% {
                transform: rotateY(0deg);
                opacity: 1;
            }
            100% { 
                transform: rotateY(180deg); 
                opacity: 0;
            }
        }

        .tile.back-animation .back-tile {
            animation: flyInFromBottomRight 0.5s var(--natural-ease) forwards;
        }

        .tile.flip-all .back-tile {
            animation: flipAndHide 0.6s var(--natural-ease) forwards;
        }



        /* The moving ghost */
        #drag-ghost {
            position: fixed; top: 0; left: 0;
            pointer-events: none; z-index: 9999; 
            visibility: hidden; will-change: transform;
        }
        .ghost-tile {
            position: absolute; background-repeat: no-repeat;
            box-shadow: 0 25px 50px rgba(0,0,0,0.6); 
            border-radius: 8px; border: 2px solid rgba(255,255,255,0.8);
            transform: scale(1.05);
            filter: brightness(1.1);
        }

        /* Tutorial System */
        #tutorial-overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 5000; pointer-events: none; display: none; }
        #tutorial-hand {
            position: absolute; width: 60px; height: 60px; background-size: contain; background-repeat: no-repeat;
            animation: handGuide 3.5s ease-in-out infinite;
        }
        @keyframes handGuide {
            0% { transform: translate(var(--fromX), var(--fromY)) scale(1); opacity: 0; }
            15% { opacity: 1; }
            30% { transform: translate(var(--fromX), var(--fromY)) scale(0.8); }
            65% { transform: translate(var(--toX), var(--toY)) scale(0.8); }
            85% { opacity: 1; transform: translate(var(--toX), var(--toY)) scale(1); }
            100% { opacity: 0; }
        }

        #final-image {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            border-radius: 12px; opacity: 0; pointer-events: none;
            transition: opacity 1.5s ease; z-index: 8000; object-fit: cover;
        }
        .reveal-state #final-image { opacity: 1; }
    </style>
</head>
<body>

    <div id="status-container"><div id="status">Ready?</div></div>

    <div id="game-container">
        <div id="tutorial-overlay"><div id="tutorial-hand"></div></div>
        <img id="final-image" src="">
        <div id="game-board"></div>
    </div>

    <div id="drag-ghost"></div>

    <script>

         // =========================================================
    //  GLOBAL CONFIGURATION (The Source of Truth)
    // =========================================================
      /*!{{GAME_OBJECT}}*/window.game_object = {
            GameElements: { 
                MainImages_1: { 
                name: "Main Image 1",
                data: "girl/Girl.png"
             },

            BackImage: {
                name: "Back Image",
                data: "back.png"
            }
        },
            GameProperties: { 
                HintTime: {
                    name: "Hint Time",
                    amount: 5000 }, 
                GridRows: {
                    name: "Grid Rows",
                    amount: 3 },
                GridCols: { 
                    name: "Grid Columns",
                    amount: 3 }
            },
            GameThemes: {
                default: "Warm",
                Warm: { background: "#edf2f7", tileColor: "#cbd5e0", labelColor: "#2d3748" }
            },
            Ui: { HandSprite: {
                name: "Hand Sprite",
                data: "BubbleIdle.png" } }
        };


        // =========================================================
    //  GAME LOGIC      
    // =========================================================
    
        const CFG = window.game_object;
        const R = CFG.GameProperties.GridRows.amount;
        const C = CFG.GameProperties.GridCols.amount;
        const IMG = CFG.GameElements.MainImages_1.data;
        const BACK_IMG = CFG.GameElements.BackImage.data;
        const TOTAL = R * C;
        
        let order = Array.from(Array(TOTAL).keys());
        let done = false, idleTimer = null;
        let animationComplete = false;
        
        const board = document.getElementById('game-board');
        const ghost = document.getElementById('drag-ghost');
        const overlay = document.getElementById('tutorial-overlay');

        function init() {
            const theme = CFG.GameThemes[CFG.GameThemes.default];
            document.documentElement.style.setProperty('--bg', theme.background);
            document.documentElement.style.setProperty('--tileColor', theme.tileColor);
            document.documentElement.style.setProperty('--labelColor', theme.labelColor);
            document.documentElement.style.setProperty('--grid-cols', C);
            document.documentElement.style.setProperty('--grid-rows', R);
            
            document.getElementById('final-image').src = IMG;
            document.getElementById('tutorial-hand').style.backgroundImage = `url(${CFG.Ui.HandSprite.data})`;
            
            order = order.sort(() => Math.random() - 0.5);
            
            // Start with back animation
            renderBackAnimation();
        }

        function renderBackAnimation() {
            board.innerHTML = '';
            
            // Create all tiles first
            const tiles = [];
            for (let i = 0; i < TOTAL; i++) {
                const t = document.createElement('div');
                t.className = 'tile back-animation';
                
                const backTile = document.createElement('div');
                backTile.className = 'back-tile';
                
                // Try to load the back image, but will show pattern if not available
                if (BACK_IMG) {
                    const img = new Image();
                    img.onload = () => {
                        backTile.style.backgroundImage = `url("${BACK_IMG}")`;
                    };
                    img.src = BACK_IMG;
                }
                
                t.appendChild(backTile);
                t.dataset.index = i;
                
                // Stagger the fly-in animation
                backTile.style.animationDelay = `${i * 0.1}s`;
                
                board.appendChild(t);
                tiles.push(t);
            }
            
            // After all tiles have flown in, flip them all at once
            const lastTileDelay = (TOTAL - 1) * 0.1;
            const flyInDuration = 0.5;
            
            setTimeout(() => {
                // Remove back-animation class and add flip-all to all tiles simultaneously
                tiles.forEach(t => {
                    t.classList.remove('back-animation');
                    t.classList.add('flip-all');
                    const backTile = t.querySelector('.back-tile');
                    backTile.style.animationDelay = '0s'; // All flip at same time
                });
                
                // After flip completes, show game tiles immediately
                setTimeout(() => {
                    animationComplete = true;
                    render(false); // NO animation delay for game tiles
                    document.getElementById('status').innerText = "RESTORE IMAGE";
                    startIdleTimer();
                }, 600); // Duration of flip animation
                
            }, (lastTileDelay + flyInDuration) * 1000);
        }

        function render(animate = true) {
            if (!animationComplete) return;
            
            board.innerHTML = '';
            order.forEach((pid, idx) => {
                const t = document.createElement('div');
                t.className = 'tile game-tile';
                t.style.backgroundImage = `url("${IMG}")`;
                t.style.backgroundSize = `${C * 100}% ${R * 100}%`;
                const px = pid % C, py = Math.floor(pid / C);
                t.style.backgroundPosition = `${(px * (100/(C-1)))}% ${(py * (100/(R-1)))}%`;
                t.dataset.index = idx;

                if (!animate) { t.style.animation = 'none'; t.style.opacity = '1'; }
                else { t.style.animationDelay = `${idx * 0.05}s`; }
                
                t.onpointerdown = (e) => startDrag(e, idx);
                board.appendChild(t);
            });
        }

        function startDrag(e, startIdx) {
            if(done || !animationComplete) return;
            hideHint();
            
            const tiles = document.querySelectorAll('.tile');
            const target = tiles[startIdx];
            const rect = target.getBoundingClientRect();
            
            const offX = e.clientX - rect.left;
            const offY = e.clientY - rect.top;

            target.style.animation = 'none'; 
            
            ghost.innerHTML = '';
            const g = target.cloneNode(true);
            g.className = 'ghost-tile';
            g.style.width = rect.width + 'px'; 
            g.style.height = rect.height + 'px';
            g.style.opacity = '1'; 
            ghost.appendChild(g);

            target.style.visibility = 'hidden'; 

            ghost.style.transition = 'none';
            ghost.style.transform = `translate3d(${e.clientX - offX}px, ${e.clientY - offY}px, 0)`;
            ghost.style.visibility = 'visible';

            const move = (m) => {
                ghost.style.transform = `translate3d(${m.clientX - offX}px, ${m.clientY - offY}px, 0)`;
            };

            const up = (u) => {
                window.removeEventListener('pointermove', move);
                window.removeEventListener('pointerup', up);
                
                const hit = document.elementFromPoint(u.clientX, u.clientY);
                if (hit && hit.classList.contains('tile')) {
                    const dropIdx = parseInt(hit.dataset.index);
                    if (dropIdx !== startIdx) {
                        const targetRect = tiles[dropIdx].getBoundingClientRect();
                        
                        ghost.style.transition = `transform var(--slide-speed) var(--natural-ease)`;
                        ghost.style.transform = `translate3d(${targetRect.left}px, ${targetRect.top}px, 0)`;

                        tiles[dropIdx].style.zIndex = "10";
                        tiles[dropIdx].style.transition = `transform var(--slide-speed) var(--natural-ease)`;
                        tiles[dropIdx].style.transform = `translate3d(${rect.left - targetRect.left}px, ${rect.top - targetRect.top}px, 0)`;

                        setTimeout(() => {
                            [order[startIdx], order[dropIdx]] = [order[dropIdx], order[startIdx]];
                            endMove();
                        }, 510);
                        return;
                    }
                }
                endMove();
            };

            function endMove() {
                ghost.style.visibility = 'hidden';
                render(false);
                winCheck();
                startIdleTimer();
            }

            window.addEventListener('pointermove', move);
            window.addEventListener('pointerup', up);
        }

        function showHint() {
            if(done) return;
            const correctPos = order.findIndex((v,i) => v!==i);
            if(correctPos === -1) return;
            const currentPos = order.indexOf(correctPos);
            
            const ts = document.querySelectorAll('.tile');
            const bR = board.getBoundingClientRect();
            const s = ts[currentPos].getBoundingClientRect(), t = ts[correctPos].getBoundingClientRect();
            
            overlay.style.setProperty('--fromX', `${s.left - bR.left + 25}px`);
            overlay.style.setProperty('--fromY', `${s.top - bR.top + 25}px`);
            overlay.style.setProperty('--toX', `${t.left - bR.left + 25}px`);
            overlay.style.setProperty('--toY', `${t.top - bR.top + 25}px`);
            overlay.style.display = 'block';
        }

        function hideHint() { overlay.style.display='none'; clearTimeout(idleTimer); }
        function startIdleTimer() { clearTimeout(idleTimer); if(!done) idleTimer = setTimeout(showHint, CFG.GameProperties.HintTime.amount); }

        function winCheck() {
            if (order.every((v,i) => v===i)) {
                done = true;
                confetti({particleCount: 150, spread: 70});
                document.getElementById('status').innerText = "SUCCESS âœ¨";
                setTimeout(() => document.getElementById('game-container').classList.add('reveal-state'), 1000);
            }
        }

        window.onload = init;
    </script>
</body>
</html>